
//typedef void;
typedef NullType;
typedef bool;
typedef int;
typedef long;
typedef float;
typedef unicode;

// type

template #Tvoid(): void {
	void
}

template #Tvar() {
}

template #Tboolean(): bool {
	bool
}

template #Tint8(): int {
	int
}

template #Tint16(): int {
	int
}

template #Tint32(): int {
	int
}

template #Tint64(): long {
	long
}

template #Tint(): long {
	long
}

template #cast(x: long) : int {
	int(${x})
}

template #cast(x: int) : long {
	long(${x})
}

template #Tfloat(): float {
	float
}

template #Tdouble(): float {
	float
}

template #Treal(): float {
	float
}

template #cast(x: int) : float {
	float(${x})
}

template #TString(): unicode {
	unicode
}

// literal

template #null(): NullType {
	None
}

template #true(): bool {
	True
}

template #false(): bool {
	False
}

template #int(): int {
	${textof this}
}

template #int32(): int {
	${textof this}
}

template #int64(): long {
	${textof this}
}

template #float(): float {
	${textof this}
}

template #double(): float {
	${textof this}
}

template #string(): unicode {
	u"${textof this}"
}

template #conv(x: float): int {
	int(${x})
}

template #conv(x: int): float {
	float(${x})
}

template<T> #group(expr :T) :T {
	(${expr})
}

template #not(x: bool) :bool {
	not ${x}
}

template #plus(x: int) :int {
	+${x}
}

template #plus(x: float) :float {
	+${x}
}

template #minus(x: int) :int {
	-${x}
}

template #minus(x: float) :float {
	-${x}
}

template #compl(x: int) :int {
	~${x}
}

template #and(x: bool, y: bool): bool {
	${x} and ${y}
}

template #or(x: bool, y: bool): bool {
	${x} or ${y}
}

template<T> #assign(x: T, y: T): void {
	${x} = ${y}
}

template<T> #add(x: T, y: T) :T {
	(${x} + ${y})
}

template #add(x: unicode, y: any !unicode): unicode {
	(${x} + unicode(${y}))
}

template<T> #sub(x: T, y: T): T {
	(${x} - ${y})
}

template<T> #mul(x: T, y: T): T {
	(${x} * ${y})
}

template<T> #div(x: T, y: T): T {
	(${x} / ${y})
}

template<T> #mod(x: T, y: T): T {
	(${x} % ${y})
}

template<T> #eq(x: T, y: T): bool {
	(${x} == ${y})
}

template<T> #noteq(x: T, y: T): bool {
	(${x} != ${y})
}

template<T> #lt(x: T, y: T): bool {
	(${x} < ${y})
}

template<T> #lte(x: T, y: T): bool {
	(${x} <= ${y})
}

template<T> #gt(x: T, y: T): bool {
	(${x} > ${y})
}

template<T> #gte(x: T, y: T): bool {
	(${x} >= ${y})
}

template #field(o: any, field) {
	${o}->${textof field}
}

template #index(o: any, index) {
	${o}[${index}]
}


template<T> #let(name, type: T, value: T): void {
	${name} = ${value}
}

template<T> #var(name, type: T, value: T): void {
	${name} = ${value}
}

template #name() {
	${textof name}
}

template #function(name, params, rtype, block): void {
	def ${name}(${list params ", "}): ${begin} ${block} ${end}
}

template #param(name, type): void {
	${name}
}

template #arguments(*) {
	(${list this ", "})
}

template #apply(f, args) {
	${f}(${list args ", "})
}


template #return(): void {
	return
}

template #return(expr): void {
	return ${expr}
}

template #empty(): void {
}

template #block(*): void {
	${statement this}
}

template #if(x: bool, then: void): void {
	if ${x}: ${begin} ${statement then} ${end}
}

template #if(x: bool, then: void, else: void): void {
	if ${x}: ${begin} ${statement then} ${end}
	else: ${begin} ${statement else} ${end}
}

template #while(x: bool, loop: void): void {
	while ${x}: ${begin} ${statement loop} ${end}
}

template #break(): void {
	break
}

template #continue(): void {
	continue
}

template #throw(expr): void {
	raise ${expr}
}



template #toplevel(*): void {
	${statement this}
}

template #error(*) {
	#error!!
}

template assert(x: bool) :void {
	assert ${x}
}

template println(x: unicode) :void {
	print ${x}
}

template #conv(x: bool): unicode {
	(u'true' if ${x} else u'false')
}

template #conv(x: int): unicode {
	unicode(${x})
}

template #conv(x: float): unicode {
	unicode(${x})
}

// String
template size(x: unicode): int {
	len(${x})
}

template #field(o: unicode, field: 'size'): int {
	len(${o})
}

template equals(x: unicode, y: unicode): bool {
	${x} == ${y}
}

template startsWith(x: unicode, y: unicode): bool {
	${x}.startswith(${y})
}

template endsWith(x: unicode, y: unicode): bool {
	${x}.endsswith(${y})
}

template substring(x: unicode, y: int): unicode {
	${x}[${y}:]
}

template substring(x: unicode, y: int, z: int): unicode {
	${x}[${y}:${z}]
}

template indexOf(x: unicode, y: unicode): int {
	${x}.find(${y})
}

template lastIndexOf(x: unicode, y: unicode): int {
	${x}.rfind(${y})
}

template toUpperCase(x: unicode): unicode {
	${x}.upper()
}

template toLowerCase(x: unicode): unicode {
	${x}.lower()
}

/**
define _ "unicode($[0])": Func<α[],String>
define size "len($[0])": Func<α[],int>
define size "@arraysize~libbun_arraysize($[0], $[1], None)": Func<α[],int,void>
define get "$[0][$[1]]": Func<α[],int,α>
define set "$[0][$[1]] = $[2]": Func<α[],int,α,void>
define add "$[0].append($[1])": Func<α[],α,void>
define insert "$[0].insert($[1], $[2])": Func<α[],int,α,void>
define remove "$[0].remove($[1])": Func<α[],int,α>
define pop "$[0].pop($[1])": Func<α[],α>
define size "@arraysize~libbun_arraysize($[0], $[1], False)": Func<boolean[],int,void>
define size "@arraysize~libbun_arraysize($[0], $[1], 0)": Func<int[],int,void>
define size "@arraysize~libbun_arraysize($[0], $[1], 0.0)": Func<float[],int,void>
define _ "unicode($[0])": Func<Map<α>,String>
define hasKey "$[0].has_key($[1])": Func<Map<α>,String,boolean>
define get "$[0][$[1]]": Func<Map<α>,String,α>
define get "@mapget~libbun_mapget($[0],$[1],$[2])": Func<Map<α>,String,α,α>
define set "$[0][$[1]] = $[2]": Func<Map<α>,String,α,void>
define keys "$[0].keys()": Func<Map<α>,String[]>
define _ "unicode($[0])": Func<Object,String>
**/

template<T> abs(x: T): T {
	ABS(${x})
}